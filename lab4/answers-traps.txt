1. 哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？
答： a0 -a7 寄存器存放函数的参数；
       a2寄存器保留13。
2. main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）
答：对f：编译器优化后；
      对g：在汇编代码中无需函数调用。
3. printf函数位于哪个地址？
答：aupic 将 uimm20 的数字作为高 20 bit，低 12 bit 填 0，并与 pc 的值相加存入 rd 中，因此 printf 的地址 =         0x600(1536) + pc (0x30) = 0x630
4. 在main中printf的jalr之后的寄存器ra中有什么值？
答：jalr rd, offset(rs1) 会将 pc+4 的数值存入 rd 中，如果 rd 是 ra 的话代表这个指令相当于函式呼叫，否则就只是单纯的跳转，支援的范围为以 rs1 为基础的 ±2KB (-2048 ~ 2047) [7]。 auipc 的高 20 bit 搭配 jalr 的低 12 bit，就可以呼叫 pc 32-bit 范围内的所有函数。所以 ra 此时的值为 0x38。
5. 运行以下代码。
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
程序的输出是什么？
答：输出是He110 World
这是将字节映射到字符的ASCII码表。输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？
答：把i设置为0x726c6400，57616 不需要修改。
6. 在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？
printf("x=%d y=%d", 3);
答：呼叫 printf 前，编译器会将传入参数放到 a0-a7 暂存器中，跳转到 printf 后从暂存器读取，但因为我们没有指定第二个占位符的值，a2 暂存器没有被修改，所以 y 打印出来的值，为函式呼叫前存在于 a2 暂存器的任意数值。